# 専門用語やデザインパターンの説明集
## デザインパターン
### 1. Decorator
- 構造</br>
Decoratorは元のクラスをコンポジションしてオーバーライドすることで何度も別の機能を実装する．</br>
デコレートしても元のクラスの使い方と変わらない．
```
class 元の出力 {}
class デコレータ1 {}
class デコレータ2 {}
let 元の出力インスタンス = new 元の出力;
let デコレータ1インスタンス = new デコレータ1(元の出力インスタンス);
let デコレータ2インスタンス = new デコレータ2(元の出力インスタンス);
```
- 利点</br>
一つの出力ロジックが複数のアルゴリズムで動かすことができる．
- 適用に適したシーン</br>
アルゴリズムが違うパターンの物を実装する際やログ出しだけの時にも用いる．
- サンプルコード</br>
patterns/1_decorator.js

### 2. TemplateMethod
- 構造</br>
主要な構造や出力ロジックは継承元の親クラスで決まっており，</br>
継承先の小クラスではそれぞれ必要にお応じてメソッドをオーバーライドしロジックを変えていく．
```
class 基本構造 {
  method1() {}
  method2() {}
  method3() {}
  method4() {} // ここは共通
}
class 機能1 extends 基本構造 {
  method2() {} // 2だけ基本と違う
}
class 機能2 extends 基本構造 {
  //1と3が基本と違う
  method1() {}
  method3() {}
}
let 機能1インスタンス = new 機能1;
let 機能2インスタンス = new 機能2;
```
- 利点</br>
共通の構造を一つにまとめることができ，改修（変更，修正，リファクタリングなど）が容易になる．
- 適用に適したシーン</br>
中の少しのメソッド又はアルゴリズムが違うだけで，基本構造の同じ機能を複数実装する時．
- サンプルコード</br>
patterns/2_template_method.js

### 3. Factory
- 構造</br>
インスタンス化の処理をまとめて，呼び出しの際の引数に合わせて使用するインスタンスを変えている．
```
class 元の出力 {}
class デコレータ1 {}
class デコレータ2 {}
// 今回は関数だが，クラスにメソッドを書いても良い．
function createFactory(type) {
  let 元の出力インスタンス = new 元の出力;
  if(type === 'デコレータ1') {
    return new デコレータ1(元の出力インスタンス);
  } else if(type === 'デコレータ2') {
    return new デコレータ2(元の出力インスタンス);
  }
  return 元の出力インスタンス; // typeが当てはまらなければ通常オブジェクト
}

元の出力インスタンス = createFactory();
元の出力インスタンス = createFactory('デコレータ1');
元の出力インスタンス = createFactory('デコレータ2');
```
- 利点</br>
どこでインスタンス化を行っているのかが容易に判断でき，改修（変更，修正，リファクタリングなど）が容易になる．
- 適用に適したシーン</br>
デコレーションをすることで複数のクラスが誕生し，インスタンス化を多く行う際．
- サンプルコード</br>
patterns/3_factory.js

### 4. Singleton - 世界に一つのオブジェクト - [AbstractFactory]
- 構造</br>

- 利点</br>
何かしら帳簿であったり，メンバー表であったりのリストなどのデータを扱う際にただ一つのインスタンスが保証されると，
</br>他を見なくともそのインスタンスだけで完結できる．
- 適用に適したシーン</br>
あるクラスのインスタンスが一つしかないことを保証したい場合
- サンプルコード</br>
patterns/4_singleton.js

### 5. State - 状態の変更をうまく処理に反映する - [Strategy]
- 構造</br>
一つのクラス内のそれぞれのメソッドでインスタンス化している．</br>
メソッドを呼び出すことで状態を切り替えたかの様に振舞うため，処理内容が変わる．
```
class State(stateの切り替え機能などを持つ) {
  #status;
  mode1() {
    console.debug("\n> mode1です");
    this.#status = new mode1で行いたい処理のクラス(this);
  }
  mode2() {
    console.debug("\n> mode2です");
    this.#status = new mode2で行いたい処理のクラス(this);
  }
  mode3() {
    console.debug("\n> mode3です");
    this.#status = new mode3で行いたい処理のクラス(this);
  }
  method1() {行いたい処理}
  method2() {行いたい処理}
  method3() {行いたい処理}
}

// Template Methodに近い
class 基本構造 {
  method1() { 共通の基本処理（後のクラスで適宜オーバーライド） }
  method2() { 共通の基本処理（後のクラスで適宜オーバーライド） }
  method3() { 共通の基本処理（後のクラスで適宜オーバーライド） }
}

class mode1で行いたい処理のクラス extends 基本構造 {
  method2() { オーバーライドし処理を書き換える }
}
class mode2で行いたい処理のクラス extends 基本構造 {
  method2() { オーバーライドし処理を書き換える }
  method3() { オーバーライドし処理を書き換える }
}
class mode3で行いたい処理のクラス extends 基本構造 {
  method2() { オーバーライドし処理を書き換える }
  method3() { オーバーライドし処理を書き換える }
}

let Stateのインスタンス = new State();
// modeによって行われる処理(methodの内容)が違う
Stateのインスタンス.mode1();
Stateのインスタンス.method1();
Stateのインスタンス.method2();
Stateのインスタンス.method3();
Stateのインスタンス.mode2();
Stateのインスタンス.method2();
Stateのインスタンス.mode3();
Stateのインスタンス.method1();
Stateのインスタンス.method3();
```
- 利点</br>
Stateは状態の条件としてのif文を減らすことで後の状態の追加などのメンテナンスをしやすくしている．
- 適用に適したシーン</br>
Stateはそれぞれの事象が同時に起きない時に使用される．
- サンプルコード</br>
patterns/5_state.js

### 6. Storategy - ロジックの差し替え - [State]
- 構造</br>

- 利点</br>
Strategyはアルゴリズムと部品を分けることでif文を減らしている．</br>
アルゴリズムを分けることでアルゴリズムの追加，変更，メンテナンスが容易になる．
- 適用に適したシーン</br>
それぞれの事象のロジックが違う物で同時に生じる可能性のある時に使用される．</br>
Strategyは出力の変更を容易にするために，ロジックを外に出しメンテナンスを容易にした．
- サンプルコード</br>
patterns/6_strategy.js

### 7. Adapter - 相手にインターフェースを合わせる - [Decrator, Strategy]
- 構造</br>
Adapterは間に互換性のあるクラスを挟むことで，</br>
当てはめたいクラス（Clock,TimeByString）ロジックを元のクラス（MessageCreator）に利用できる形に変換していた．</br>
出力は一緒だが入力されるデータが違うため， 別で出力にデータが合う様にロジックを組み直している．
- 利点</br>

- 適用に適したシーン</br>
基本アルゴリズムは同じだがデータなどタネとなる元が違う時．
- サンプルコード</br>
patterns/7_adapter.js

### 8. Facade - 細かい事をまるっと隠す- [Decorator]
- 構造</br>

- 利点</br>
詳しいアルゴリズムがわからなくても，一番外のモジュールの使用方法がわかればよくなる．
- 適用に適したシーン</br>
多くのクラスを利用して，階層が深く，</br>
それぞれのロジックが単純でも全体としてどんな動きをするのかが把握しづらくなってきた時．
- サンプルコード</br>
patterns/8_facade.js

### 9. Composite
- 構造</br>

- 利点</br>

- 適用に適したシーン</br>

- サンプルコード</br>
patterns/


## 専門用語
- カプセル化
- 継承
- コンポジション
- ポリモーフィズム